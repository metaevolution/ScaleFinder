SCALE_FORMULAS = {
  "lydian": "1 2 3 4# 5 6 7",
  "major": "1 2 3 4 5 6 7",
  "mixolydian": "1 2 3 4 5 6 7b",
  "dorian": "1 2 3b 4 5 6 7b",
  "aeolian": "1 2 3b 4 5 6b 7b",
  "phrygian": "1 2b 3b 4 5 6b 7b",
  "locrian": "1 2b 3b 4 5b 6b 7b",
  "melodic minor": "1 2 3b 4 5 6 7",
  "melodic minor second mode": "1 2b 3b 4 5 6 7b",
  "lydian augmented": "1 2 3 4# 5A 6 7",
  "lydian dominant": "1 2 3 4# 5 6 7b",
  "melodic minor fifth mode": "1 2 3 4 5 6b 7b",
  "locrian #2": "1 2 3b 4 5b 6b 7b",
  "locrian major": "1 2 3 4 5b 6b 7b",
  "altered": "1 2b 3b 3 5b 6b 7b",
  "major pentatonic": "1 2 3 5 6",
  "lydian pentatonic": "1 3 4# 5 7",
  "mixolydian pentatonic": "1 3 4 5 7b",
  "locrian pentatonic": "1 3b 4 5b 7b",
  "minor pentatonic": "1 3b 4 5 7b",
  "minor six pentatonic": "1 3b 4 5 6",
  "minor hexatonic": "1 2 3b 4 5 7",
  "flat three pentatonic": "1 2 3b 5 6",
  "flat six pentatonic": "1 2 3 5 6b",
  "major flat two pentatonic": "1 2b 3 5 6",
  "whole tone pentatonic": "1 3 5b 6b 7b",
  "ionian pentatonic": "1 3 4 5 7",
  "lydian #5 pentatonic": "1 3 4# 5A 7",
  "lydian dominant pentatonic": "1 3 4# 5 7b",
  "minor #7 pentatonic": "1 3b 4 5 7",
  "super locrian pentatonic": "1 3b 4d 5b 7b",
  "in-sen": "1 2b 4 5 7b",
  "iwato": "1 2b 4 5b 7b",
  "hirajoshi": "1 2 3b 5 6b",
  "kumoijoshi": "1 2b 4 5 6b",
  "pelog": "1 2b 3b 5 6b",
  "vietnamese 1": "1 3b 4 5 6b",
  "vietnamese 2": "1 3b 4 5 7b",
  "prometheus": "1 2 3 4# 6 7b",
  "prometheus neopolitan": "1 2b 3 4# 6 7b",
  "ritusen": "1 2 4 5 6",
  "scriabin": "1 2b 3 5 6",
  "piongio": "1 2 4 5 6 7b",
  "major blues": "1 2 3b 3 5 6",
  "minor blues": "1 3b 4 5b 5 7b",
  "composite blues": "1 2 3b 3 4 5b 5 6 7b",
  "augmented": "1 2A 3 5 5A 7",
  "augmented heptatonic": "1 2A 3 4 5 5A 7",
  "dorian #4": "1 2 3b 4# 5 6 7b",
  "lydian diminished": "1 2 3b 4# 5 6 7",
  "whole tone": "1 2 3 4# 5A 7b",
  "leading whole tone": "1 2 3 4# 5A 7b 7",
  "harmonic minor": "1 2 3b 4 5 6b 7",
  "lydian minor": "1 2 3 4# 5 6b 7b",
  "neopolitan": "1 2b 3b 4 5 6b 7",
  "neopolitan minor": "1 2b 3b 4 5 6b 7b",
  "neopolitan major": "1 2b 3b 4 5 6 7",
  "neopolitan major pentatonic": "1 3 4 5b 7b",
  "romanian minor": "1 2 3b 5b 5 6 7b",
  "double harmonic lydian": "1 2b 3 4# 5 6b 7",
  "diminished": "1 2 3b 4 5b 6b 6 7",
  "harmonic major": "1 2 3 4 5 6b 7",
  "double harmonic major": "1 2b 3 4 5 6b 7",
  "egyptian": "1 2 4 5 7b",
  "hungarian minor": "1 2 3b 4# 5 6b 7",
  "hungarian major": "1 2A 3 4# 5 6 7b",
  "oriental": "1 2b 3 4 5b 6 7b",
  "spanish": "1 2b 3 4 5 6b 7b",
  "spanish heptatonic": "1 2b 3b 3 4 5 6b 7b",
  "flamenco": "1 2b 3b 3 4# 5 7b",
  "balinese": "1 2b 3b 4 5 6b 7",
  "todi raga": "1 2b 3b 4# 5 6b 7",
  "malkos raga": "1 3b 4 6b 7b",
  "kafi raga": "1 3b 3 4 5 6 7b 7",
  "purvi raga": "1 2b 3 4 4# 5 6b 7",
  "persian": "1 2b 3 4 5b 6b 7",
  "bebop": "1 2 3 4 5 6 7b 7",
  "bebop dominant": "1 2 3 4 5 6 7b 7",
  "bebop minor": "1 2 3b 3 4 5 6 7b",
  "bebop major": "1 2 3 4 5 5A 6 7",
  "bebop locrian": "1 2b 3b 4 5b 5 6b 7b",
  "minor bebop": "1 2 3b 4 5 6b 7b 7",
  "mystery #1": "1 2b 3 5b 6b 7b",
  "enigmatic": "1 2b 3 5b 6b 7b 7",
  "minor six diminished": "1 2 3b 4 5 6b 6 7",
  "ionian augmented": "1 2 3 4 5A 6 7",
  "lydian #9": "1 2b 3 4# 5 6 7",
  "ichikosucho": "1 2 3 4 5b 5 6 7",
  "six tone symmetric": "1 2b 3 4 5A 6"
}

MAJOR_SCALE_FORMULA = "WWHWWWH"

NOTES = ['A', 'A#', 'B', 'C', 'C#','D', 'D#', 'E', 'F', 'F#', 'G', 'G#']

SYMBOL_SHARP = "#"
SYMBOL_FLAT = "b"
SYMBOL_AUGMENTED = "A"
SYMBOL_DIMINISHED = "d"

def get_previous_note_iter(note):
    """Return the next lower note in pitch"""
    position = NOTES.index(note)
    if position == 0:  # if at 0 position, start at position 11 (0 indexed)  
        position = 11
    else: 
        position -= 1
    return NOTES[position]

def get_next_note(note):
    """Return the next higher note in pitch"""
    position = NOTES.index(note)
    if position == (len(NOTES) - 1):  # if at 11th position, start at position 0 (0 indexed)  
        position = 0
    else: 
        position += 1
    return NOTES[position]

def _note_in_list(note, include_list):
    if note in include_list:
        return note
    else:
        return ""

def get_note_sequence(note, note_range, include_list=None):
    """Return the next x number of notes in sequential order. Use 'include_list' to return only notes within a scale."""
    notes = []
    if include_list:
        notes.append(_note_in_list(note, include_list))
    else:
        notes.append(note)

    for i in range(1, note_range+1):
        note = get_next_note(note)
        if include_list:
            notes.append(_note_in_list(note, include_list))
        else:
            notes.append(note)
    return notes


def get_relative_note(note, symbol):
    """Return the note sharp or flat of the provided note"""
    position = NOTES.index(note)
    if symbol == SYMBOL_SHARP:
        if position == (len(NOTES) - 1):  # if at 11th position, start at position 0 (0 indexed)  
            position = 0
        else: 
            position += 1
    elif symbol == SYMBOL_FLAT:
        if position == 0:  # if at 0 position, start at position 11 (0 indexed)  
            position = 11
        else: 
            position -= 1
    elif symbol == SYMBOL_AUGMENTED:
        pass
    elif symbol == SYMBOL_DIMINISHED:
        pass
    return NOTES[position]


def calculate_major_scale(root_note):
    """Returns the notes of the major scale for provided root note."""
    FORMULA = [x for x in MAJOR_SCALE_FORMULA]
    note_len = len(NOTES)
    root_index = NOTES.index(root_note)
    scale = [root_note]
    position = root_index
    for f in FORMULA:
        if f == "W":
            if position == (len(NOTES) - 1):  # if at 11th position, start at position 1 (0 indexed)
                #print("%s: %s: %s: =1" % (f, position, NOTES[position]))
                position = 1
            elif position == (len(NOTES) - 2):  # if at 10th position, start at position 0 (0 indexed)
                #print("%s: %s: %s: =0" % (f, position, NOTES[position]))
                position = 0
            else: 
                #print("%s: %s: %s: +2" % (f, position, NOTES[position]))
                position += 2
        if f == "H":
            if position == (len(NOTES) - 1):  # if at 10th position, start at position 0 (0 indexed)
                #print("%s: %s: %s: =0" % (f, position, NOTES[position]))
                position = 0
            else:
                #print("%s: %s: %s: +1" % (f, position, NOTES[position]))
                position += 1
        scale.append(NOTES[position]) 
    scale.pop() # last note added is the root note again so pop it off the end of the list.
    return scale


def scale_from_pattern(root_note, scale_name, scale_pattern):
    """"""
    major = calculate_major_scale(root_note)
    pattern = scale_pattern.split(" ")
    scale = []
    for i in pattern:
        if len(i) == 1: # not sharp/flat
            note = major[int(i) - 1] 
        elif len(i) == 2: # sharp/flat
            note = get_relative_note(major[int(i[0]) - 1], i[1])
        scale.append(note)
    return(scale)



def generate_scales_iter(root_notes, scale_formulas):
    
    for k,v in scale_formulas.items():
        for j in root_notes:
            yield {'scale': k, 'formula': v, 'notes': scale_from_pattern(j, k, v), 'root_note': j}

        

def generate_scales(root_notes, scale_formulas):
    scales = []
    for k,v in scale_formulas.items():
        for j in root_notes:
            scales.append({'scale': k, 'formula': v, 'notes': scale_from_pattern(j, k, v), 'root_note': j})
    return scales


def scale_candidate_iter(submitted_notes):
    """Find scales that contain all of the notes passed to function."""
    for k,v in SCALE_FORMULAS.items():
        for j in NOTES:
            notes = scale_from_pattern(j, k, v)
            if all(elem in notes  for elem in submitted_notes):
                yield {'scale': k, 'formula': v, 'notes': notes, 'root_note': j}

if __name__ == "__main__":
    import sys
    import pprint
    notes = sys.argv[1].split(" ")
    #root_note = sys.argv[1]
    #scale = sys.argv[2]

    #try:
    #    scale_formula = SCALE_FORMULAS[scale]
    #except KeyError:
    #    print("Scale %s not found." % scale)
    #    pprint.pprint(SCALE_FORMULAS)
    #    sys.exit(1)

    #print(scale_from_pattern(root_note, scale, scale_formula))
    print("[*] Found the following matches:")
    for i in scale_candidate_iter(notes):
        print("- %s %s \r\n  notes: %s\r\n" % (i['root_note'], i['scale'], i['notes']))
